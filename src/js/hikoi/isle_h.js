//
class isle_h {
  constructor( grade, a, borderland ){
    this.const = {
      grade: grade,
      size: grade * ( grade + 1 ) + 1,
      a: a,
      m: null,
      center: null,
      layers: 2,
      estrangement: {
        base: 1,
        phase: 3,
        genesis: 2
      },
      descents: 6
    };
    this.var = {
      index: {
        domain: 0,
        pathway: 0,
        substance: 0,
      },
      current: {
        layer: 1
      }
    };
    this.array = {
      domain: [],
      pathway: [ [], [] ],
      phase: [ 0, 1, 2 ],
      genesis: [ 0, 1, 2, 3, 4 ],
      descent: [],
      substance: []
    };
    this.flag = {
    };
    this.data = {
      borderland: borderland
    };

    this.init();
  }

  init_neighbors(){
    this.array.neighbor = [
      [
        createVector( 1, -1 ),
        createVector( 1, 0 ),
        createVector( 1, 1 ),
        createVector( 0, 1 ),
        createVector( -1, 0 ),
        createVector( 0, -1 )
      ],
      [
        createVector( 0, -1 ),
        createVector( 1, 0 ),
        createVector( 0, 1 ),
        createVector( -1, 1 ),
        createVector( -1, 0 ),
        createVector( -1, -1 )
      ]
    ];
  }

  init_domains(){
    //
    this.array.domain = [];

    for( let i = 0; i < this.const.m; i++ ){
      this.array.domain.push( [] );

      for( let j = 0; j < this.const.m; j++ ){
        let vec = createVector( this.const.r * 2 * j, this.const.a * 1.5 * i );
        if( i % 2 == 1 )
          vec.x += this.const.r;

        this.array.domain[i].push( new domain_h( this.var.index.domain, vec, this.const.a ) );
        this.var.index.domain++;
      }
    }

    this.domains_around_capital();
  }

  init_pathways(){
    this.array.pathway = [ [], [] ];

    for( let p = 0; p < 2; p++ ){
      let centers = [];
      let current_arrays = [];
      let d_max = null;
      let add_l = null;

      switch ( p ) {
        case 0:
          current_arrays = this.array.domain;
          d_max = this.const.r * 2 * 1.1;
          add_l = this.const.m + 1;
          break;
      }

      for( let current_array of current_arrays )
        for( let current of current_array )
          if( current.flag.visiable )
            centers.push( {
              index: current.const.index,
              center: current.const.center.copy()
            } );


      for( let i = 0; i < centers.length; i++ ){
        let center = centers[i].center;
        let l = i + add_l;

        if( l > centers.length )
          l = centers.length;

        for( let j = i + 1; j < l; j++ ){
          let d = centers[i].center.dist( centers[j].center );

          if( d < d_max ){
            let ends = [ centers[i].index, centers[j].index ];
            let vectors = [ centers[i].center, centers[j].center ];

            this.array.pathway[p].push( new pathway_h( this.var.index.pathway, ends, vectors ) );
            this.var.index.pathway++;
          }
        }
      }
    }

    for( let domains of this.array.domain )
      for( let domain of domains )
        if( domain.flag.visiable )
          for( let pathway of this.array.pathway[0] )
            domain.add_pathway( pathway );
  }

  init_substances(){
    let primary_substances = [ 0, 0, 1, 1, 2, 2 ];

    for( let descent of this.array.descent ){
      let grid = this.convert_index( descent );
      let parity = ( grid.y + 1 ) % 2;
      let rand = Math.floor( Math.random() * this.array.neighbor[parity].length );

      grid.add( this.array.neighbor[parity][rand] );
      rand = Math.floor( Math.random() * primary_substances.length );
      let phase = primary_substances[rand];
      let domain = this.array.domain[grid.y][grid.x];
      let genesis = 0;
      let concentration = 0;

      this.add_substance( domain, phase, genesis, concentration );
      primary_substances.splice( rand, 1 );
    }

    for( let phase of this.array.phase ){

    }
  }

  init(){
    this.const.r = this.const.a / ( Math.tan( Math.PI / 6 ) * 2 );
    this.const.m = ( this.const.size + 1 ) * 2 + 1;

    this.init_neighbors();
    this.init_domains();
    this.init_pathways();
    this.init_substances();
  }

  domains_around_capital(){
    let half = this.const.size;
    let core = this.array.domain[half][half];
    let arounds = [ core.const.index ];
    core.set_status( 3 );
    this.const.center = core.const.center.copy();

    for( let i = 0; i < half; i++ )
      for( let j = arounds.length - 1; j >= 0; j-- ){
        let grid = this.convert_index( arounds[j] );
        let parity = ( grid.y + 1 ) % 2;

        for( let neighbor of this.array.neighbor[parity] ){
          grid = this.convert_index( arounds[j] );
          grid.add( neighbor );
          let around = this.convert_grid( grid );

          if( !arounds.includes( around ) && this.check_border( grid ) ){
            if( i < this.const.grade )
              this.array.domain[grid.y][grid.x].set_status( 3 );

            arounds.push( around );
          }
        }
      }

    let sorted = [];

    for( let i = 0; i < arounds.length; i++ ){
      let grid = this.convert_index( arounds[i] );

      if( this.array.domain[grid.y][grid.x].var.status == 0 )
        this.array.domain[grid.y][grid.x].set_status( 1 );

      sorted.push( {
        'domain': arounds[i]
      } );
    }

    sorted = this.bubble_sort( sorted, 'domain' );
    let domains = [];
    let cols = this.const.size + 1;
    let index = 0;
    let cols_add = 1;

    for( let i = 0; i < this.const.m - 2; i++ ){
      domains.push( [] );

      for( let j = 0; j < cols; j++ ){
        if( sorted.length > index )
          domains[i].push( sorted[index]['domain'] );

        index++;
      }

      if( i == this.const.size )
        cols_add = -1;

      cols += cols_add;
    }

    for( let i = 0; i < this.const.descents; i++ ){
      let grid = this.convert_index( core.const.index );

      for( let j = 0; j < half - 1; j++ ){
        let parity = ( grid.y + 1 ) % 2;
        let neighbor = this.array.neighbor[parity][i];
        grid.add( neighbor );
      }

      this.array.domain[grid.y][grid.x].set_status( 2 );
      this.array.descent.push( this.array.domain[grid.y][grid.x].const.index );
    }
  }

  path_between_domains( begin, end, type ){
    let current_grid = begin.copy();
    let counter = 0;
    let stopper = this.const.m * 2;
    let current_d = current_grid.dist( end );
    let steps = [];

    while( current_d != 0 && counter < stopper ){
      let parity = ( current_grid.y + 1 ) % 2;
      let step = null;
      let min_d = Math.pow( this.const.m, 2 );

      for( let neighbor of this.array.neighbor[parity] ){
        let next_grid = current_grid.copy();
        next_grid.add( neighbor );

        if( this.check_border( next_grid ) ){
          let next_d = next_grid.dist( end );
          let flag = true;

          if( type == 0 )
            flag = !this.array.domain[next_grid.y][next_grid.x].flag.el_dorado;

          if( next_d < min_d && flag ){
            min_d = next_d;
            step = neighbor.copy();
          }
        }
      }

      current_grid.add( step );
      current_d = current_grid.dist( end );
      steps.push( step );
      counter++;
    }

    current_grid = begin.copy();

    for( let step of steps ){
      current_grid.add( step );
    }

  if( steps.length == stopper && type != 1 )
    console.log( 'steps error' );
    return steps;
  }

  add_substance( domain, phase, genesis, concentration ){
    this.array.substance.push( new substance_h( this.var.index.substance, this.const.a, domain, phase, genesis, concentration ) );
    this.var.index.substance++;
  }

  bubble_sort( arr, key ){
    for( let i = 0; i < arr.length - 1; i++ ){
      let flag = false;

      for( let j = 0; j < arr.length - 1 - i; j++ )
        if( arr[j][key] > arr[j + 1][key] ){
          [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
          flag = true;
        }

      if ( !flag ) break;
    }

    return arr;
  }

  //find the grid coordinates by index
  convert_index( index ){
    if( index == undefined )
      return null;

    let i = Math.floor( index / this.const.m );
    let j = index % this.const.m;
    return createVector( j, i );
  }

  //find the index coordinates by grid coordinates
  convert_grid( vec ){
    if( vec == undefined )
      return null;

    return vec.y * this.const.m + vec.x;
  }

  check_border( grid ){
    let flag = ( grid.x >= this.const.m ) || ( grid.x < 0 ) || ( grid.y >= this.const.m ) || ( grid.y < 0 );

    return !flag;
  }

  click(){
  }

  key(){
    switch ( keyCode ) {
      case 32:
        this.var.current.layer = ( this.var.current.layer + 1 ) % this.const.layers;
        console.log( this.var.current.layer )
        break;
    }
  }

  draw( offset ){
    if( this.var.current.layer == 1 )
      for( let pathway of this.array.pathway[0] )
        pathway.draw( offset );

    if( this.var.current.layer == 2 )
      for( let pathway of this.array.pathway[1] )
        pathway.draw( offset );

    if( this.var.current.layer == 0 ||
        this.var.current.layer == 1 ||
        this.var.current.layer == 3 )
      for( let domains of this.array.domain )
        for( let domain of domains )
          domain.draw( offset, this.var.current.layer );
  }
}
